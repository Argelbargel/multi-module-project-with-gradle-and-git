import org.gradle.internal.os.OperatingSystem;
// we have to use the git command on the path because GrGit does not release directories properly even when closed
if (!OperatingSystem.current().isWindows() && "where git.exe".execute().waitFor() != 0) {
    logger.error("update-modules.gradle requires git.exe in path!")
    throw new GradleException("update-modules.gradle requires git.exe in path!")
} else if ("which git".execute().waitFor() != 0) {
    logger.error("update-modules requires git.exe in path!")
    throw new GradleException("update-module.gradle requires git.exe in path!")
}

def projectDir = gradle.startParameter.currentDir.canonicalPath
def allModulesFile = file("$projectDir/modules.properties")
def myModulesFile = file("$projectDir/my-modules.properties")
def selectedModules = null
def myModules = new Properties();
def allModules = new Properties();
allModules.load(new FileReader(allModulesFile))
def allModuleNames = Collections.list(allModules.propertyNames())

if (myModulesFile.exists()) {
    myModules.load(new FileReader(myModulesFile))
}


if (gradle.startParameter.projectProperties.containsKey("modules")) {
    def moduleParam = gradle.startParameter.projectProperties.get("modules").trim();
    if (moduleParam == "") {
        selectedModules = null
    } else if (moduleParam == "--none") {
        selectedModules = []
    } else if (moduleParam == "--all") {
        selectedModules = Collections.list(allModules.propertyNames())
    } else {
        selectedModules = Arrays.asList(moduleParam.split('\\s*[,\\s]\\s*'))
    }
}


import groovy.swing.SwingBuilder
import java.awt.BorderLayout as BL

if (selectedModules == null) {
    def myModuleNames = Collections.list(myModules.propertyNames())
    Collections.sort(allModuleNames)

    new SwingBuilder().edt {
        dialog(modal: true,
                title: 'Module ausw√§hlen',
                alwaysOnTop: true,
                resizable: false,
                locationRelativeTo: null,
                pack: true,
                show: true
        ) {
            borderLayout()
            hbox(constraints: BL.NORTH) {
                button(defaultButton: false, text: 'Alle', actionPerformed: {
                    moduleCheckBoxes.each { it.selected = true }
                })

                button(defaultButton: false, text: 'Keines', actionPerformed: {
                    moduleCheckBoxes.each { it.selected = false }
                })
            }

            vbox {
                moduleCheckBoxes = []
                for (String module : allModuleNames) {
                    moduleCheckBoxes += checkBox(module, selected: myModuleNames.contains(module))
                }
            }

            hbox(constraints: BL.SOUTH) {
                button(defaultButton: true, text: 'OK', actionPerformed: {
                    selectedModules = moduleCheckBoxes.findAll { it.selected }.collect { it.text }
                    dispose();
                })

                button(defaultButton: false, text: 'Abbrechen', actionPerformed: {
                    selectedModules = null
                    dispose();
                })
            }
        }
    }
}


if (selectedModules == null) {
    throw new GradleException("update-modules aborted")
}


myModules = new Properties();
selectedModules.each {
    if (!(it in allModuleNames)) {
        throw new GradleException("unknown module $it")
    }

    myModules.setProperty(it, allModules.getProperty(it))
}

myModules.store(new FileWriter(myModulesFile), "active modules")
apply plugin: InitializeModulesPlugin


class InitializeModulesPlugin implements Plugin<Gradle> {
    @Override
    public void apply(Gradle gradle) {
        Properties modules = new Properties();
        def projectDir = gradle.startParameter.currentDir.canonicalPath
        def myModulesFile = new File(projectDir, "my-modules.properties")
        def allModulesFile = new File(projectDir, "modules.properties")
        modules.load(new FileReader(myModulesFile.exists() ? myModulesFile : allModulesFile))
        for (String module : modules.propertyNames()) {
            def directory = new File(projectDir, "modules/${module}")
            def uri = modules.getProperty(module)
            if (!directory.exists()) {
                println("Cloning module $module from $uri to $directory...")
                "git clone $uri ${directory.canonicalPath}".execute().waitFor()
            } else {
                println("Module $module from $uri already exists at $directory")
            }
        }
    }
}

